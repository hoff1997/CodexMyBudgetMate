#!/bin/bash
#
# Pre-commit hook: Scans staged files for hardcoded secrets.
# Blocks the commit if any are found.
#
# Setup: git config core.hooksPath .githooks
# Or run: npm run setup-hooks
#
# To bypass in emergencies: git commit --no-verify
#

RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

echo ""
echo "ğŸ”’ Scanning for secrets..."

# Get staged files (only added/modified, not deleted)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
  exit 0
fi

FOUND_SECRETS=0

# Patterns to detect secrets
# Each pattern: "REGEX|||DESCRIPTION"
PATTERNS=(
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9|||JWT token (Supabase service role or anon key)'
  'SUPABASE_SERVICE_ROLE_KEY\s*=\s*["\x27]eyJ|||Supabase service role key with JWT value'
  'service_role_key\s*=\s*["\x27]eyJ|||Service role key with JWT value'
  'createClient\(\s*["\x27]https://[a-z0-9]+\.supabase\.co["\x27]\s*,\s*["\x27]eyJ|||createClient with hardcoded URL and key'
  'sk_live_[a-zA-Z0-9]{20,}|||Stripe live secret key'
  'sk_test_[a-zA-Z0-9]{20,}|||Stripe test secret key'
  'whsec_[a-zA-Z0-9]{20,}|||Stripe webhook secret'
  'AKAHU_CLIENT_SECRET\s*=\s*["\x27][a-zA-Z0-9]|||Hardcoded Akahu client secret'
  'AKAHU_WEBHOOK_SECRET\s*=\s*["\x27][a-zA-Z0-9]|||Hardcoded Akahu webhook secret'
  'password\s*[:=]\s*["\x27][^"\x27]{6,}["\x27]|||Hardcoded password'
  'PRIVATE_KEY\s*=\s*["\x27]|||Hardcoded private key'
)

# Files to skip (binary, lock files, the hook itself, etc.)
SKIP_PATTERNS="(\.png|\.jpg|\.jpeg|\.gif|\.svg|\.ico|\.woff|\.woff2|\.ttf|\.eot|\.map|package-lock\.json|\.lock|node_modules|\.githooks/pre-commit|CLAUDE\.md)"

for FILE in $STAGED_FILES; do
  # Skip binary/lock files
  if echo "$FILE" | grep -qE "$SKIP_PATTERNS"; then
    continue
  fi

  # Skip .env files (they should be gitignored, but just in case)
  if echo "$FILE" | grep -qE "^\.env"; then
    echo -e "${RED}âŒ BLOCKED: .env file staged for commit: $FILE${NC}"
    echo "   Remove it: git reset HEAD $FILE"
    FOUND_SECRETS=1
    continue
  fi

  # Get the staged content of the file
  CONTENT=$(git show ":$FILE" 2>/dev/null)
  if [ -z "$CONTENT" ]; then
    continue
  fi

  for PATTERN_ENTRY in "${PATTERNS[@]}"; do
    PATTERN=$(echo "$PATTERN_ENTRY" | cut -d'|' -f1)
    DESCRIPTION=$(echo "$PATTERN_ENTRY" | cut -d'|' -f4-)

    # Search for pattern in staged content
    MATCHES=$(echo "$CONTENT" | grep -nE "$PATTERN" 2>/dev/null)
    if [ -n "$MATCHES" ]; then
      echo ""
      echo -e "${RED}âŒ POTENTIAL SECRET FOUND${NC}"
      echo -e "   ${YELLOW}Type:${NC} $DESCRIPTION"
      echo -e "   ${YELLOW}File:${NC} $FILE"
      echo -e "   ${YELLOW}Lines:${NC}"
      echo "$MATCHES" | head -3 | while read -r line; do
        LINE_NUM=$(echo "$line" | cut -d: -f1)
        LINE_CONTENT=$(echo "$line" | cut -d: -f2- | head -c 80)
        echo "     Line $LINE_NUM: ${LINE_CONTENT}..."
      done
      FOUND_SECRETS=1
    fi
  done
done

echo ""

if [ $FOUND_SECRETS -ne 0 ]; then
  echo -e "${RED}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
  echo -e "${RED}  COMMIT BLOCKED: Potential secrets detected!${NC}"
  echo -e "${RED}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
  echo ""
  echo "  Options:"
  echo "  1. Remove the secrets and use environment variables instead"
  echo "  2. If this is a false positive, bypass with: git commit --no-verify"
  echo ""
  exit 1
else
  echo -e "${GREEN}âœ… No secrets detected. Proceeding with commit.${NC}"
  echo ""
  exit 0
fi
